/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
import { Inject, Injectable } from '@angular/core';
import * as i0 from "@angular/core";
export class InputFileService {
    /**
     * @param {?} _config
     */
    constructor(_config) {
        this._config = _config;
    }
    /**
     * @return {?}
     */
    get config() {
        return this._config;
    }
    /**
     * Whether the limit is not reached.
     * @param {?} files
     * @param {?} fileLimit
     * @return {?}
     */
    limitGuard(files, fileLimit) {
        return files.length < fileLimit;
    }
    /**
     * Whether the file size is not bigger than the limit.
     * @param {?} file
     * @param {?} sizeLimit
     * @return {?}
     */
    sizeGuard(file, sizeLimit) {
        return !sizeLimit || file.size < sizeLimit * 1024 * 1024; // TODO : improve
    }
    /**
     * Whether the type of the file is enabled.
     * @param {?} file
     * @param {?} fileAccept
     * @return {?}
     */
    typeGuard(file, fileAccept) {
        /** @type {?} */
        let enabled = fileAccept == null;
        if (fileAccept) {
            /** @type {?} */
            const accept = fileAccept.replace('*', '');
            /** @type {?} */
            const types = accept.split(',');
            for (const type of types) {
                if (file.type.startsWith(type) || (type.charAt(0) === '.' && file.name != null && file.name.endsWith(type))) {
                    enabled = true;
                    break;
                }
            }
        }
        return enabled;
    }
}
InputFileService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
InputFileService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: ['config',] }] }
];
/** @nocollapse */ InputFileService.ngInjectableDef = i0.defineInjectable({ factory: function InputFileService_Factory() { return new InputFileService(i0.inject("config")); }, token: InputFileService, providedIn: "root" });
if (false) {
    /** @type {?} */
    InputFileService.prototype._config;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQtZmlsZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWlucHV0LWZpbGUvIiwic291cmNlcyI6WyJzcmMvbGliL3NlcnZpY2VzL2lucHV0LWZpbGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBT25ELE1BQU0sT0FBTyxnQkFBZ0I7Ozs7SUFFekIsWUFDOEIsT0FBd0I7UUFBeEIsWUFBTyxHQUFQLE9BQU8sQ0FBaUI7SUFDbEQsQ0FBQzs7OztJQUVMLElBQUksTUFBTTtRQUNOLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN4QixDQUFDOzs7Ozs7O0lBTU0sVUFBVSxDQUFDLEtBQXVCLEVBQUUsU0FBUztRQUNoRCxPQUFPLEtBQUssQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDO0lBQ3BDLENBQUM7Ozs7Ozs7SUFPTSxTQUFTLENBQUMsSUFBVSxFQUFFLFNBQWlCO1FBQzFDLE9BQU8sQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLElBQUksR0FBRyxTQUFTLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLGlCQUFpQjtJQUMvRSxDQUFDOzs7Ozs7O0lBT00sU0FBUyxDQUFDLElBQVUsRUFBRSxVQUFrQjs7WUFDdkMsT0FBTyxHQUFHLFVBQVUsSUFBSSxJQUFJO1FBQ2hDLElBQUksVUFBVSxFQUFFOztrQkFDTixNQUFNLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDOztrQkFDcEMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO1lBQy9CLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFO2dCQUN0QixJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtvQkFDekcsT0FBTyxHQUFHLElBQUksQ0FBQztvQkFDZixNQUFNO2lCQUNUO2FBQ0o7U0FDSjtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ25CLENBQUM7OztZQWpESixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7Ozs7NENBSVEsTUFBTSxTQUFDLFFBQVE7Ozs7O0lBQWhCLG1DQUFrRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSW5wdXRGaWxlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9pbnB1dC1maWxlJztcbmltcG9ydCB7IElucHV0RmlsZUNvbmZpZyB9IGZyb20gJy4uL2ludGVyZmFjZXMvaW5wdXQtZmlsZS1jb25maWcnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIElucHV0RmlsZVNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoJ2NvbmZpZycpIHByaXZhdGUgX2NvbmZpZzogSW5wdXRGaWxlQ29uZmlnXG4gICAgKSB7IH1cblxuICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbGltaXQgaXMgbm90IHJlYWNoZWQuXG4gICAgICogQHBhcmFtIGZpbGVzXG4gICAgICovXG4gICAgcHVibGljIGxpbWl0R3VhcmQoZmlsZXM6IEFycmF5PElucHV0RmlsZT4sIGZpbGVMaW1pdCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmlsZXMubGVuZ3RoIDwgZmlsZUxpbWl0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGZpbGUgc2l6ZSBpcyBub3QgYmlnZ2VyIHRoYW4gdGhlIGxpbWl0LlxuICAgICAqIEBwYXJhbSBmaWxlXG4gICAgICogQHBhcmFtIHNpemVMaW1pdFxuICAgICAqL1xuICAgIHB1YmxpYyBzaXplR3VhcmQoZmlsZTogRmlsZSwgc2l6ZUxpbWl0OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICFzaXplTGltaXQgfHwgZmlsZS5zaXplIDwgc2l6ZUxpbWl0ICogMTAyNCAqIDEwMjQ7IC8vIFRPRE8gOiBpbXByb3ZlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgdHlwZSBvZiB0aGUgZmlsZSBpcyBlbmFibGVkLlxuICAgICAqIEBwYXJhbSBmaWxlXG4gICAgICogQHBhcmFtIGZpbGVBY2NlcHRcbiAgICAgKi9cbiAgICBwdWJsaWMgdHlwZUd1YXJkKGZpbGU6IEZpbGUsIGZpbGVBY2NlcHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgZW5hYmxlZCA9IGZpbGVBY2NlcHQgPT0gbnVsbDtcbiAgICAgICAgaWYgKGZpbGVBY2NlcHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2VwdCA9IGZpbGVBY2NlcHQucmVwbGFjZSgnKicsICcnKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVzID0gYWNjZXB0LnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZS50eXBlLnN0YXJ0c1dpdGgodHlwZSkgfHwgKHR5cGUuY2hhckF0KDApID09PSAnLicgJiYgZmlsZS5uYW1lICE9IG51bGwgJiYgZmlsZS5uYW1lLmVuZHNXaXRoKHR5cGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVuYWJsZWQ7XG4gICAgfVxufVxuIl19